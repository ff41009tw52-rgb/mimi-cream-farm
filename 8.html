<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qç‰ˆé›»è·¯å°å¯¦é©—</title>
    
    <!-- å¼•å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- å¼•å…¥ React å’Œ ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- å¼•å…¥ Babel ç”¨æ–¼è§£æ JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #fffbeb; }
        /* é˜²æ­¢é¸å–æ–‡å­— */
        .no-select { user-select: none; -webkit-user-select: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- ç°¡æ˜“åœ–ç¤ºå…ƒä»¶ (æ›¿ä»£ lucide-react) ---
        const IconBase = ({ children, color = "currentColor", size = 24, ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={color} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                {children}
            </svg>
        );

        const Plus = (props) => <IconBase {...props}><path d="M5 12h14"/><path d="M12 5v14"/></IconBase>;
        const RotateCcw = (props) => <IconBase {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></IconBase>;
        const Zap = (props) => <IconBase {...props}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></IconBase>;
        const Power = (props) => <IconBase {...props}><path d="M18.36 6.64a9 9 0 1 1-12.73 0"/><line x1="12" y1="2" x2="12" y2="12"/></IconBase>;
        const Lightbulb = (props) => <IconBase {...props}><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-1 1.5-2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5"/><path d="M9 18h6"/><path d="M10 22h4"/></IconBase>;
        const Eye = (props) => <IconBase {...props}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></IconBase>;
        const EyeOff = (props) => <IconBase {...props}><path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"/><line x1="2" y1="2" x2="22" y2="22"/></IconBase>;
        const RotateCw = (props) => <IconBase {...props}><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></IconBase>;

        // --- å…ƒä»¶å®šç¾© ---

        const COMPONENT_TYPES = {
            BATTERY: 'battery',
            BULB: 'bulb'
        };

        // åˆå§‹ä½ç½®
        const INITIAL_COMPONENTS = [
            { id: 'bulb-1', type: COMPONENT_TYPES.BULB, x: 400, y: 150, rotation: 0 },
            { id: 'bat-1', type: COMPONENT_TYPES.BATTERY, x: 250, y: 350, rotation: 0 },
        ];

        function CircuitGame() {
            const [components, setComponents] = useState(INITIAL_COMPONENTS);
            const [wires, setWires] = useState([]);
            
            // ç‹€æ…‹ç®¡ç†
            const [isDrawing, setIsDrawing] = useState(false);
            const [currentWireStart, setCurrentWireStart] = useState(null);
            
            const [draggingCompId, setDraggingCompId] = useState(null);
            const [draggingWireId, setDraggingWireId] = useState(null); 
            const [rotatingCompId, setRotatingCompId] = useState(null); 
            
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 }); 
            
            const [litBulbIds, setLitBulbIds] = useState(new Set());
            const [brightness, setBrightness] = useState(0); 
            const [errorMsg, setErrorMsg] = useState('');

            // æ§åˆ¶é¡¯ç¤ºè¼”åŠ©é»çš„ç‹€æ…‹
            const [showControls, setShowControls] = useState(true);
            
            // é›»æºé–‹é—œç‹€æ…‹
            const [isSwitchOn, setIsSwitchOn] = useState(false);

            const canvasRef = useRef(null);

            // --- æ ¸å¿ƒæ•¸å­¸ï¼šå–å¾—æ—‹è½‰å¾Œçš„æ¥é»åº§æ¨™ ---
            const getConnectionPoint = (comp, pointType) => {
                if (!comp) return { x: 0, y: 0 };
                
                // å®šç¾©å…ƒä»¶å°ºå¯¸èˆ‡ç›¸å°æ¥é»ä½ç½® (æœªæ—‹è½‰å‰)
                let width, height, localX, localY;

                if (comp.type === COMPONENT_TYPES.BATTERY) {
                width = 140; height = 60;
                if (pointType === 'pos') { localX = 10; localY = 40; } // æ­£æ¥µ
                else if (pointType === 'neg') { localX = 130; localY = 40; } // è² æ¥µ
                } else if (comp.type === COMPONENT_TYPES.BULB) {
                width = 80; height = 140;
                if (pointType === 'thread') { localX = 20; localY = 100; } // èºç´‹
                else if (pointType === 'tip') { localX = 40; localY = 125; } // åº•éƒ¨
                }

                if (localX === undefined) return { x: 0, y: 0 };

                // è¨ˆç®—ä¸­å¿ƒé»
                const cx = comp.x + width / 2;
                const cy = comp.y + height / 2;

                // è¨ˆç®—ç›¸å°æ–¼ä¸­å¿ƒçš„åº§æ¨™
                const relX = (comp.x + localX) - cx;
                const relY = (comp.y + localY) - cy;

                // æ—‹è½‰è®Šæ›çŸ©é™£
                const rad = (comp.rotation * Math.PI) / 180;
                const rotatedX = relX * Math.cos(rad) - relY * Math.sin(rad);
                const rotatedY = relX * Math.sin(rad) + relY * Math.cos(rad);

                // è½‰å›çµ•å°åº§æ¨™
                return {
                x: cx + rotatedX,
                y: cy + rotatedY
                };
            };

            // --- è¼”åŠ©å‡½æ•¸ï¼šè¨ˆç®—é›»ç·šå¹¾ä½• ---
            const getWireGeometry = (startPos, endPos, controlOffset) => {
                const midX = (startPos.x + endPos.x) / 2;
                const midY = (startPos.y + endPos.y) / 2;
                const cpX = midX + (controlOffset?.x || 0);
                const cpY = midY + (controlOffset?.y || 0);
                return { cpX, cpY, midX, midY };
            };

            // --- äº‹ä»¶è™•ç† ---

            const handleMouseMove = (e) => {
                if (!canvasRef.current) return;
                
                const containerRect = canvasRef.current.getBoundingClientRect();
                const x = e.clientX - containerRect.left;
                const y = e.clientY - containerRect.top;
                setMousePos({ x, y });

                // A. æ‹–æ›³å…ƒä»¶
                if (draggingCompId) {
                setComponents(prev => prev.map(c => {
                    if (c.id === draggingCompId) {
                    return { ...c, x: x - dragOffset.x, y: y - dragOffset.y };
                    }
                    return c;
                }));
                }
                
                // B. æ—‹è½‰å…ƒä»¶
                if (rotatingCompId) {
                setComponents(prev => prev.map(c => {
                    if (c.id === rotatingCompId) {
                    let width = c.type === COMPONENT_TYPES.BATTERY ? 140 : 80;
                    let height = c.type === COMPONENT_TYPES.BATTERY ? 60 : 140;
                    const cx = c.x + width / 2;
                    const cy = c.y + height / 2;
                    
                    const angleRad = Math.atan2(y - cy, x - cx);
                    let angleDeg = angleRad * (180 / Math.PI);
                    angleDeg += 90; 

                    return { ...c, rotation: angleDeg };
                    }
                    return c;
                }));
                }

                // C. æ‹–æ›³é›»ç·šæ§åˆ¶é»
                if (draggingWireId) {
                setWires(prev => prev.map(w => {
                    if (w.id === draggingWireId) {
                    const startComp = components.find(c => c.id === w.start.compId);
                    const endComp = components.find(c => c.id === w.end.compId);
                    if (!startComp || !endComp) return w;

                    const startPos = getConnectionPoint(startComp, w.start.pointType);
                    const endPos = getConnectionPoint(endComp, w.end.pointType);
                    
                    const midX = (startPos.x + endPos.x) / 2;
                    const midY = (startPos.y + endPos.y) / 2;

                    return {
                        ...w,
                        controlOffset: {
                        x: x - midX,
                        y: y - midY
                        }
                    };
                    }
                    return w;
                }));
                }
            };

            const handleGlobalMouseUp = () => {
                setDraggingCompId(null);
                setDraggingWireId(null);
                setRotatingCompId(null);
                
                if (isDrawing) {
                setIsDrawing(false);
                setCurrentWireStart(null);
                }
            };

            const handleMouseDownComp = (e, id) => {
                e.stopPropagation();
                if (isDrawing) return;
                if (isSwitchOn) togglePower();

                if (!canvasRef.current) return;
                const comp = components.find(c => c.id === id);
                const containerRect = canvasRef.current.getBoundingClientRect();
                const offsetX = e.clientX - containerRect.left - comp.x;
                const offsetY = e.clientY - containerRect.top - comp.y;

                setDraggingCompId(id);
                setDragOffset({ x: offsetX, y: offsetY });
            };

            const handleRotateMouseDown = (e, id) => {
                e.stopPropagation();
                if (isSwitchOn) togglePower();
                setRotatingCompId(id);
            }

            const handleNodeMouseDown = (e, compId, pointType) => {
                e.stopPropagation();
                e.preventDefault();
                if (!showControls) return;
                if (isSwitchOn) togglePower();

                setIsDrawing(true);
                setCurrentWireStart({ compId, pointType });
                setLitBulbIds(new Set()); 
                setErrorMsg('');
            };

            const handleNodeMouseUp = (e, compId, pointType) => {
                e.stopPropagation();
                if (isDrawing && currentWireStart) {
                if (currentWireStart.compId === compId && currentWireStart.pointType === pointType) {
                    setIsDrawing(false);
                    setCurrentWireStart(null);
                    return;
                }
                const exists = wires.some(w => 
                    (w.start.compId === currentWireStart.compId && w.start.pointType === currentWireStart.pointType && w.end.compId === compId && w.end.pointType === pointType) ||
                    (w.end.compId === currentWireStart.compId && w.end.pointType === currentWireStart.pointType && w.start.compId === compId && w.start.pointType === pointType)
                );

                if (!exists) {
                    setWires([...wires, {
                    id: `wire-${Date.now()}`,
                    start: currentWireStart,
                    end: { compId, pointType },
                    controlOffset: { x: 0, y: 50 } 
                    }]);
                }
                setIsDrawing(false);
                setCurrentWireStart(null);
                }
            };

            const handleWireControlMouseDown = (e, wireId) => {
                e.stopPropagation();
                if (!showControls) return;
                setDraggingWireId(wireId);
            };

            // --- åŠŸèƒ½æŒ‰éˆ• ---
            const addBattery = () => {
                if (isSwitchOn) togglePower();
                if (components.filter(c => c.type === COMPONENT_TYPES.BATTERY).length >= 5) {
                setErrorMsg('æœ€å¤šåªèƒ½ä½¿ç”¨äº”é¡†é›»æ± å–”ï¼');
                return;
                }
                setComponents([...components, { id: `bat-${Date.now()}`, type: COMPONENT_TYPES.BATTERY, x: 100, y: 350, rotation: 0 }]);
                setLitBulbIds(new Set());
            };

            const addBulb = () => {
                if (isSwitchOn) togglePower();
                if (components.filter(c => c.type === COMPONENT_TYPES.BULB).length >= 5) {
                setErrorMsg('æœ€å¤šåªèƒ½ä½¿ç”¨äº”é¡†ç‡ˆæ³¡å–”ï¼');
                return;
                }
                const offset = components.filter(c => c.type === COMPONENT_TYPES.BULB).length * 60; 
                setComponents([...components, { id: `bulb-${Date.now()}`, type: COMPONENT_TYPES.BULB, x: 150 + offset, y: 150 + (offset % 100), rotation: 0 }]);
                setLitBulbIds(new Set());
            };

            const resetBoard = () => {
                setComponents(INITIAL_COMPONENTS);
                setWires([]);
                setLitBulbIds(new Set());
                setBrightness(0);
                setErrorMsg('');
                setIsDrawing(false);
                setCurrentWireStart(null);
                setShowControls(true); 
                setIsSwitchOn(false);
            };

            const removeWire = (id) => {
                if (isSwitchOn) togglePower();
                setWires(wires.filter(w => w.id !== id));
                setLitBulbIds(new Set());
            };

            const togglePower = () => {
                if (isSwitchOn) {
                setIsSwitchOn(false);
                setLitBulbIds(new Set());
                setBrightness(0);
                setErrorMsg('');
                } else {
                setIsSwitchOn(true);
                runSimulation();
                }
            };

            // --- æ ¸å¿ƒé‚è¼¯ ---
            const runSimulation = () => {
                setErrorMsg('');
                setLitBulbIds(new Set());
                setBrightness(0);

                const adj = {};
                
                components.forEach(c => {
                    if (c.type === COMPONENT_TYPES.BATTERY) {
                        adj[`${c.id}:pos`] = [];
                        adj[`${c.id}:neg`] = [];
                    } else {
                        adj[`${c.id}:thread`] = [];
                        adj[`${c.id}:tip`] = [];
                    }
                });

                wires.forEach(w => {
                const u = `${w.start.compId}:${w.start.pointType}`;
                const v = `${w.end.compId}:${w.end.pointType}`;
                if (adj[u]) adj[u].push(v);
                if (adj[v]) adj[v].push(u);
                });

                const batteries = components.filter(c => c.type === COMPONENT_TYPES.BATTERY);
                
                if (batteries.length === 0) {
                    setErrorMsg('éœ€è¦é›»æ± æ‰èƒ½ä¾›é›»ï¼');
                    setIsSwitchOn(false);
                    return;
                }

                const successfulPathBulbs = new Set();

                const findPath = (current, targetNegNodes, pathVisited, pathBulbs) => {
                    pathVisited.add(current);

                    if (targetNegNodes.has(current)) {
                        return true;
                    }

                    const [compId, pointType] = current.split(':');
                    const comp = components.find(c => c.id === compId);

                    let nextNodes = [];

                    if (adj[current]) {
                        adj[current].forEach(neighbor => {
                            if (!pathVisited.has(neighbor)) {
                                nextNodes.push(neighbor);
                            }
                        });
                    }

                    if (comp && comp.type === COMPONENT_TYPES.BULB) {
                        const otherPoint = pointType === 'tip' ? 'thread' : 'tip';
                        const internalNode = `${compId}:${otherPoint}`;
                        if (!pathVisited.has(internalNode)) {
                            nextNodes.push(internalNode);
                        }
                    }
                    
                    if (comp && comp.type === COMPONENT_TYPES.BATTERY && pointType === 'neg') {
                        const posNode = `${compId}:pos`;
                        if (!pathVisited.has(posNode)) {
                            nextNodes.push(posNode);
                        }
                    }

                    for (const nextNode of nextNodes) {
                        const newPathBulbs = new Set(pathBulbs);
                        
                        const [nextId, nextType] = nextNode.split(':');
                        const nextComp = components.find(c => c.id === nextId);
                        
                        if (nextComp.type === COMPONENT_TYPES.BULB && compId === nextId) {
                            newPathBulbs.add(nextId);
                        }

                        if (findPath(nextNode, targetNegNodes, new Set(pathVisited), newPathBulbs)) {
                            newPathBulbs.forEach(b => successfulPathBulbs.add(b));
                            return true;
                        }
                    }

                    return false;
                };

                const allNegNodes = new Set(batteries.map(b => `${b.id}:neg`));

                batteries.forEach(bat => {
                    findPath(`${bat.id}:pos`, allNegNodes, new Set(), new Set());
                });

                if (successfulPathBulbs.size > 0) {
                    setLitBulbIds(successfulPathBulbs);
                    const brightnessLevel = batteries.length >= 2 ? 2 : 1;
                    setBrightness(brightnessLevel);

                    if (brightnessLevel === 2) {
                        setErrorMsg(`é›»æºå·²é–‹å•Ÿï¼${successfulPathBulbs.size}é¡†ç‡ˆæ³¡ç™¼å…‰ (é«˜äº®åº¦)ï¼`);
                    } else {
                        setErrorMsg(`é›»æºå·²é–‹å•Ÿï¼${successfulPathBulbs.size}é¡†ç‡ˆæ³¡ç™¼å…‰ã€‚`);
                    }
                } else {
                    setErrorMsg('é›»æºå·²é–‹å•Ÿï¼Œä½†æœªå½¢æˆå®Œæ•´è¿´è·¯ã€‚');
                }
            };

            return (
                <div className="flex flex-col items-center min-h-screen bg-amber-50 font-sans no-select overflow-hidden"
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleGlobalMouseUp}
                >
                <div className="w-full bg-white shadow-md p-4 flex justify-between items-center z-10 gap-4 flex-wrap">
                    <h1 className="text-2xl font-bold text-slate-700 flex items-center gap-2 mr-auto">
                    <Zap className="text-yellow-500 fill-yellow-500" />
                    Qç‰ˆé›»è·¯å°å¯¦é©—
                    </h1>
                    
                    <div className="flex gap-2">
                    <button 
                        onClick={() => setShowControls(!showControls)}
                        className={`flex items-center gap-1 px-4 py-2 rounded-full transition font-bold ${showControls ? 'bg-purple-100 text-purple-700 hover:bg-purple-200' : 'bg-gray-200 text-gray-500 hover:bg-gray-300'}`}
                    >
                        {showControls ? <Eye size={18} /> : <EyeOff size={18} />}
                        <span className="hidden sm:inline">{showControls ? "éš±è—è¼”åŠ©" : "é¡¯ç¤ºè¼”åŠ©"}</span>
                    </button>

                    <button onClick={addBattery} className="flex items-center gap-1 px-4 py-2 bg-blue-100 text-blue-700 rounded-full hover:bg-blue-200 transition font-bold"><Plus size={18} /> é›»æ± </button>
                    <button onClick={addBulb} className="flex items-center gap-1 px-4 py-2 bg-yellow-100 text-yellow-700 rounded-full hover:bg-yellow-200 transition font-bold"><Lightbulb size={18} /> ç‡ˆæ³¡</button>
                    <button onClick={resetBoard} className="flex items-center gap-1 px-4 py-2 bg-gray-100 text-gray-700 rounded-full hover:bg-gray-200 transition font-bold"><RotateCcw size={18} /> é‡ç½®</button>
                    
                    <button 
                        onClick={togglePower} 
                        className={`flex items-center gap-1 px-6 py-2 text-white rounded-full transition shadow-lg transform active:scale-95 font-bold text-lg min-w-[140px] justify-center
                        ${isSwitchOn ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600'}
                        `}
                    >
                        <Power size={20} /> 
                        {isSwitchOn ? "é—œé–‰é›»æº" : "é–‹å•Ÿé›»æº"}
                    </button>
                    </div>
                </div>

                <div className={`mt-4 px-6 py-2 rounded-lg text-lg font-bold transition-all duration-300 ${
                    litBulbIds.size > 0 ? 'bg-yellow-100 text-yellow-800 border-2 border-yellow-400' : 
                    errorMsg ? (isSwitchOn ? 'bg-orange-100 text-orange-800' : 'bg-slate-200 text-slate-700') : 'bg-transparent text-transparent'
                }`}>
                    {errorMsg || "æº–å‚™å°±ç·’ï¼Œè«‹é€£æ¥é›»è·¯ä¸¦é–‹å•Ÿé›»æº"}
                </div> 

                <div className="relative w-full flex-grow cursor-crosshair overflow-hidden" ref={canvasRef}>
                    
                    <div className="absolute inset-0 pointer-events-none opacity-10" style={{ backgroundImage: 'radial-gradient(#94a3b8 1px, transparent 1px)', backgroundSize: '20px 20px' }}></div>

                    <div className="absolute bottom-4 left-4 text-slate-400 pointer-events-none z-0">
                    {showControls ? (
                        <>
                        <p>ğŸ’¡ æ‹–æ›³å…ƒä»¶ç§»å‹•ä½ç½®</p>
                        <p>ğŸ”Œ æŒ‰ä½æ¥é»ä¸¦æ‹–æ›³ä¾†æ‹‰é›»ç·š</p>
                        <p>â†» ä½¿ç”¨ä¸Šæ–¹ç´«è‰²åœ“é»æ—‹è½‰å…ƒä»¶</p>
                        </>
                    ) : (
                        <p>ğŸ“· è§€è³æ¨¡å¼</p>
                    )}
                    </div>

                    <svg className="absolute inset-0 w-full h-full pointer-events-none z-0">
                    {wires.map(wire => {
                        const startComp = components.find(c => c.id === wire.start.compId);
                        const endComp = components.find(c => c.id === wire.end.compId);
                        if (!startComp || !endComp) return null;
                        
                        const startPos = getConnectionPoint(startComp, wire.start.pointType);
                        const endPos = getConnectionPoint(endComp, wire.end.pointType);
                        const { cpX, cpY } = getWireGeometry(startPos, endPos, wire.controlOffset);

                        return (
                        <g key={wire.id}>
                            <path d={`M ${startPos.x} ${startPos.y} Q ${cpX} ${cpY} ${endPos.x} ${endPos.y}`} stroke="#475569" strokeWidth="8" fill="none" strokeLinecap="round" />
                            <path d={`M ${startPos.x} ${startPos.y} Q ${cpX} ${cpY} ${endPos.x} ${endPos.y}`} stroke="#000000" strokeWidth="4" fill="none" strokeLinecap="round" />
                        </g>
                        );
                    })}
                    {isDrawing && currentWireStart && (() => {
                        const startComp = components.find(c => c.id === currentWireStart.compId);
                        const startPos = getConnectionPoint(startComp, currentWireStart.pointType);
                        const midX = (startPos.x + mousePos.x) / 2;
                        const midY = (startPos.y + mousePos.y) / 2;
                        return (
                        <g>
                            <path d={`M ${startPos.x} ${startPos.y} Q ${midX} ${midY + 50} ${mousePos.x} ${mousePos.y}`} stroke="#000000" strokeWidth="4" fill="none" strokeLinecap="round" />
                            <path d={`M ${startPos.x} ${startPos.y} Q ${midX} ${midY + 50} ${mousePos.x} ${mousePos.y}`} stroke="#fbbf24" strokeWidth="8" fill="none" strokeLinecap="round" opacity="0.3" />
                            <circle cx={mousePos.x} cy={mousePos.y} r="6" fill="#000000" />
                        </g>
                        )
                    })()}
                    </svg>

                    {showControls && wires.map(wire => {
                        const startComp = components.find(c => c.id === wire.start.compId);
                        const endComp = components.find(c => c.id === wire.end.compId);
                        if (!startComp || !endComp) return null;
                        const startPos = getConnectionPoint(startComp, wire.start.pointType);
                        const endPos = getConnectionPoint(endComp, wire.end.pointType);
                        const { cpX, cpY } = getWireGeometry(startPos, endPos, wire.controlOffset);
                        const midCurveX = 0.25 * startPos.x + 0.5 * cpX + 0.25 * endPos.x;
                        const midCurveY = 0.25 * startPos.y + 0.5 * cpY + 0.25 * endPos.y;

                        return (
                        <React.Fragment key={`controls-${wire.id}`}>
                            <div className="absolute w-4 h-4 bg-blue-500 rounded-full border-2 border-white shadow-md cursor-move hover:scale-125 transition-transform z-30 pointer-events-auto" style={{ left: cpX - 8, top: cpY - 8 }} onMouseDown={(e) => handleWireControlMouseDown(e, wire.id)} title="èª¿æ•´å½¢ç‹€"></div>
                            <div className="absolute w-5 h-5 bg-red-100 hover:bg-red-500 hover:text-white text-red-500 rounded-full flex items-center justify-center cursor-pointer shadow-md border border-red-200 transition-colors z-30 pointer-events-auto" style={{ left: midCurveX - 10, top: midCurveY - 10 }} onClick={(e) => { e.stopPropagation(); removeWire(wire.id); }} title="ç§»é™¤é›»ç·š"><span className="text-xs font-bold leading-none mb-[1px]">Ã—</span></div>
                        </React.Fragment>
                        );
                    })}

                    {components.map(comp => (
                    <div
                        key={comp.id}
                        className="absolute z-20"
                        style={{ 
                        left: comp.x, 
                        top: comp.y, 
                        width: comp.type === COMPONENT_TYPES.BATTERY ? 140 : 80,
                        height: comp.type === COMPONENT_TYPES.BATTERY ? 60 : 140,
                        transform: `rotate(${comp.rotation}deg)`,
                        }}
                    >
                        {showControls && (
                            <div 
                            className="absolute left-1/2 -top-8 -ml-3 w-6 h-6 bg-purple-500 rounded-full border-2 border-white shadow-md cursor-grab active:cursor-grabbing hover:scale-110 flex items-center justify-center z-50 pointer-events-auto"
                            onMouseDown={(e) => handleRotateMouseDown(e, comp.id)}
                            title="æ—‹è½‰å…ƒä»¶"
                            >
                            <RotateCw size={14} className="text-white" />
                            </div>
                        )}

                        <div 
                        className="w-full h-full cursor-grab active:cursor-grabbing"
                        onMouseDown={(e) => handleMouseDownComp(e, comp.id)}
                        >
                            {comp.type === COMPONENT_TYPES.BATTERY && (
                            <BatteryComponent 
                                id={comp.id} 
                                onNodeMouseDown={handleNodeMouseDown} 
                                onNodeMouseUp={handleNodeMouseUp}
                                isDrawing={isDrawing} 
                                currentStart={currentWireStart}
                                showControls={showControls}
                            />
                            )}
                            {comp.type === COMPONENT_TYPES.BULB && (
                            <BulbComponent 
                                id={comp.id} 
                                onNodeMouseDown={handleNodeMouseDown} 
                                onNodeMouseUp={handleNodeMouseUp}
                                isLit={litBulbIds.has(comp.id)}
                                brightness={brightness}
                                isDrawing={isDrawing}
                                currentStart={currentWireStart}
                                showControls={showControls}
                            />
                            )}
                        </div>
                    </div>
                    ))}

                </div>
                </div>
            );
        }

        function BatteryComponent({ id, onNodeMouseDown, onNodeMouseUp, isDrawing, currentStart, showControls }) {
            const canConnect = isDrawing && currentStart && currentStart.compId !== id;
            return (
                <div className="relative w-[140px] h-[60px] select-none group">
                <div className="absolute inset-0 bg-gradient-to-b from-gray-700 to-gray-800 rounded-lg shadow-lg border-2 border-gray-900 flex items-center justify-center overflow-hidden">
                    <div className="absolute top-1 bottom-1 left-3 right-3 bg-gradient-to-r from-orange-400 to-orange-500 rounded flex items-center justify-between px-2">
                        <span className="text-white font-bold text-xl ml-1">+</span>
                        <div className="flex gap-1 opacity-30"><div className="w-1 h-4 bg-orange-700 rounded-full"></div><div className="w-1 h-4 bg-orange-700 rounded-full"></div><div className="w-1 h-4 bg-orange-700 rounded-full"></div></div>
                        <span className="text-white font-bold text-xl mr-1">-</span>
                    </div>
                    <div className="absolute top-1 left-2 right-2 h-3 bg-white opacity-20 rounded-full"></div>
                </div>
                <div className="absolute left-[-8px] top-[15px] w-2 h-8 bg-gray-400 rounded-l-sm border-l border-t border-b border-gray-600"></div>
                
                {showControls && (
                    <>
                    <div className={`absolute left-0 top-[20px] w-6 h-6 rounded-full border-2 border-white shadow-sm z-30 cursor-pointer transition-transform hover:scale-125 ${canConnect ? 'bg-yellow-400 scale-125 animate-pulse' : 'bg-red-500 hover:bg-red-400'}`} onMouseDown={(e) => onNodeMouseDown(e, id, 'pos')} onMouseUp={(e) => onNodeMouseUp(e, id, 'pos')} title="æ­£æ¥µ (+)"></div>
                    <div className={`absolute right-0 top-[20px] w-6 h-6 rounded-full border-2 border-white shadow-sm z-30 cursor-pointer transition-transform hover:scale-125 ${canConnect ? 'bg-yellow-400 scale-125 animate-pulse' : 'bg-blue-500 hover:bg-blue-400'}`} onMouseDown={(e) => onNodeMouseDown(e, id, 'neg')} onMouseUp={(e) => onNodeMouseUp(e, id, 'neg')} title="è² æ¥µ (-)"></div>
                    </>
                )}
                </div>
            );
        }

        function BulbComponent({ id, onNodeMouseDown, onNodeMouseUp, isLit, brightness, isDrawing, currentStart, showControls }) {
            const canConnect = isDrawing && currentStart && currentStart.compId !== id;
            const lightStyles = isLit ? { filter: brightness > 1 ? 'drop-shadow(0 0 30px #fde047) drop-shadow(0 0 60px #facc15)' : 'drop-shadow(0 0 15px #fde047)', opacity: 1 } : { filter: 'none', opacity: 0.8 };
            const bulbColor = isLit ? (brightness > 1 ? '#fef08a' : '#fef9c3') : '#e2e8f0';

            return (
                <div className="relative w-[80px] h-[140px] flex flex-col items-center select-none">
                {isLit && (<div className={`absolute top-0 w-32 h-32 rounded-full bg-yellow-300 blur-2xl -z-10 transition-opacity duration-500 ${brightness > 1 ? 'opacity-80' : 'opacity-40'}`}></div>)}
                <div className="w-[70px] h-[70px] rounded-full border-2 border-gray-400 z-10 relative transition-colors duration-500 overflow-hidden" style={{ backgroundColor: bulbColor, ...lightStyles }}>
                    <div className="absolute top-3 left-3 w-6 h-6 bg-white rounded-full opacity-60"></div>
                    <div className="absolute top-5 left-8 w-2 h-2 bg-white rounded-full opacity-60"></div>
                    <div className="absolute bottom-2 left-1/2 transform -translate-x-1/2 w-6 h-6 border-t-2 border-gray-600 rounded-full opacity-50"></div>
                </div>
                <div className="relative w-10 h-12 bg-gray-300 border border-gray-500 flex flex-col items-center -mt-2 z-20">
                    <div className="w-full h-[1px] bg-gray-500 mt-2 transform -rotate-6"></div>
                    <div className="w-full h-[1px] bg-gray-500 mt-2 transform -rotate-6"></div>
                    <div className="w-full h-[1px] bg-gray-500 mt-2 transform -rotate-6"></div>
                    {showControls && <div className={`absolute -left-3 top-3 w-5 h-5 rounded-full border-2 border-white shadow-sm cursor-pointer hover:scale-125 transition-transform ${canConnect ? 'bg-yellow-400 scale-125 animate-pulse' : 'bg-green-500 hover:bg-green-400'}`} onMouseDown={(e) => onNodeMouseDown(e, id, 'thread')} onMouseUp={(e) => onNodeMouseUp(e, id, 'thread')} title="èºç´‹æ¥é»"></div>}
                </div>
                <div className="w-8 h-4 bg-black rounded-b-lg relative z-20 flex justify-center">
                    {showControls && <div className={`absolute -bottom-2 w-5 h-5 rounded-full border-2 border-white shadow-sm cursor-pointer hover:scale-125 transition-transform ${canConnect ? 'bg-yellow-400 scale-125 animate-pulse' : 'bg-green-500 hover:bg-green-400'}`} onMouseDown={(e) => onNodeMouseDown(e, id, 'tip')} onMouseUp={(e) => onNodeMouseUp(e, id, 'tip')} title="åº•éƒ¨æ¥é»"></div>}
                </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<CircuitGame />);
    </script>
</body>
</html>