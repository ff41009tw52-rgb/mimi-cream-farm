<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>沙子與食鹽分離實驗 V42 (堆積平衡修正版)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f8f9fa; font-family: "Noto Sans TC", sans-serif; }
        canvas { display: block; }
        
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 320px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            border: 1px solid #eee;
            transition: all 0.3s ease;
            z-index: 10;
        }

        h1 { margin: 0 0 15px 0; font-size: 1.4rem; color: #333; display: flex; align-items: center; }
        h1 span { margin-right: 10px; font-size: 1.6rem; }

        .step-indicator {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .step-dot {
            width: 10px; height: 10px; background: #ddd; border-radius: 50%;
            transition: background 0.3s;
        }
        .step-dot.active { background: #007bff; transform: scale(1.2); }

        .instruction-box {
            min-height: 60px;
            margin-bottom: 20px;
        }
        .step-title { color: #007bff; font-weight: bold; font-size: 1.1rem; margin-bottom: 5px; display: block; }
        .step-desc { color: #666; font-size: 0.95rem; line-height: 1.5; }

        .controls { display: flex; flex-direction: column; gap: 10px; }
        
        button {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border: none;
            padding: 14px;
            font-size: 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,123,255,0.2);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        button:hover { transform: translateY(-1px); box-shadow: 0 6px 8px rgba(0,123,255,0.3); }
        button:active { transform: translateY(1px); box-shadow: 0 2px 4px rgba(0,123,255,0.2); }
        button:disabled { background: #ccc; cursor: not-allowed; box-shadow: none; transform: none; }

        .legend { margin-top: 20px; font-size: 0.85rem; color: #555; background: #f1f3f5; padding: 10px; border-radius: 8px; }
        .legend-row { display: flex; align-items: center; margin-bottom: 6px; }
        .legend-row:last-child { margin-bottom: 0; }
        .dot { width: 12px; height: 12px; margin-right: 8px; display: inline-block; border-radius: 50%; }

    </style>
</head>
<body>

    <div id="ui-container">
        <h1><span>⚗️</span>分離實驗模擬</h1>
        
        <div class="step-indicator" id="dots">
            <div class="step-dot active"></div>
            <div class="step-dot"></div>
            <div class="step-dot"></div>
            <div class="step-dot"></div>
        </div>

        <div class="instruction-box">
            <span id="s-title" class="step-title">步驟 1：觀察混合物</span>
            <div id="s-desc" class="step-desc">觀察燒杯內的物質，可以看到深色的沙子和白色的食鹽混合在一起。</div>
        </div>

        <div class="controls">
            <button id="main-btn">開始實驗：加水</button>
            <button id="reset-btn" style="background: #6c757d; display: none;">重新開始</button>
        </div>

        <div class="legend">
            <div class="legend-row"><span class="dot" style="background:#5D4037;"></span>沙子 (不溶)</div>
            <div class="legend-row"><span class="dot" style="background:#fff; border:1px solid #ccc;"></span>食鹽 (可溶)</div>
            <div class="legend-row"><span class="dot" style="background:#81D4FA;"></span>水 / 食鹽水</div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        // --- 全局狀態 ---
        let step = 0; 
        let animFrame;
        let autoStepTimer = null;
        const MAX_BOTTOM_LEVEL = 90; 
        
        // --- 顏色定義 ---
        const SAND_COLOR = '#5D4037';
        const SALT_COLOR = '#FFFFFF';
        const WATER_COLOR = 'rgba(129, 212, 250, 0.7)'; 
        const WATER_STROKE = 'rgba(79, 195, 247, 1.0)';
        
        // --- 物件狀態 ---
        let beakerA = {
            x: 0, y: 0, w: 150, h: 200, 
            angle: 0,
            waterVolume: 0, 
            maxVolume: 85,
            particles: [],
            spoutLocal: { x: -75 - 15, y: -100 - 5 }, 
            isPouring: false 
        };

        let jug = { x: 0, y: 0, angle: 0, visible: false, flow: false, returned: false, flowDone: false };
        let rod = { x: 0, y: 0, angle: 0, visible: false, moving: false };
        
        let filterSetup = {
            x: 0, y: 0, visible: false,
            beakerBWaterLevel: 0,
            trappedSand: [], 
            fallingParticles: [], 
            sieveRadius: 60,
            pileHeights: new Array(130).fill(0), 
            beakerBSize: { w: 140, h: 160 }
        };

        const titleEl = document.getElementById('s-title');
        const descEl = document.getElementById('s-desc');
        const mainBtn = document.getElementById('main-btn');
        const resetBtn = document.getElementById('reset-btn');
        const dots = document.querySelectorAll('.step-dot');

        function init() {
            resize();
            window.addEventListener('resize', resize);
            resetExperiment();
            loop();
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            if (step === 0) resetPositions();
        }

        function resetPositions() {
            beakerA.x = width * 0.45; 
            beakerA.y = height * 0.7;
            filterSetup.x = width * 0.8;
            filterSetup.y = height * 0.7;
        }

        function resetExperiment() {
            if (autoStepTimer) clearTimeout(autoStepTimer);
            step = 0;
            mainBtn.disabled = false;
            updateUI(0);
            resetPositions();
            
            beakerA.angle = 0;
            beakerA.waterVolume = 0;
            beakerA.particles = [];
            beakerA.isPouring = false;
            
            jug.visible = false; 
            jug.angle = 0; 
            jug.flow = false; 
            jug.returned = false;
            jug.flowDone = false; 
            
            rod.visible = false;
            
            filterSetup.visible = false;
            filterSetup.beakerBWaterLevel = 0;
            filterSetup.trappedSand = [];
            filterSetup.fallingParticles = [];
            filterSetup.pileHeights.fill(0);

            const fillHeight = beakerA.h / 3; 
            const bottomY = beakerA.h / 2;

            for(let i=0; i<300; i++) {
                beakerA.particles.push({
                    type: 'sand',
                    x: (Math.random() - 0.5) * (beakerA.w - 30),
                    y: bottomY - 5 - Math.random() * fillHeight, 
                    r: 2.5 + Math.random() * 1.5,
                    vx: 0, vy: 0,
                    alpha: 1
                });
            }
            for(let i=0; i<250; i++) {
                beakerA.particles.push({
                    type: 'salt',
                    x: (Math.random() - 0.5) * (beakerA.w - 30),
                    y: bottomY - 5 - Math.random() * fillHeight,
                    r: 2.5,
                    vx: 0, vy: 0,
                    alpha: 1
                });
            }
        }

        function rotatePoint(x, y, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return { x: x * cos - y * sin, y: x * sin + y * cos };
        }

        function getSpoutTipWorldPos(beaker) {
            if (!beaker.spoutLocal) return { x: beaker.x, y: beaker.y - beaker.h/2 };
            const p = rotatePoint(beaker.spoutLocal.x, beaker.spoutLocal.y, beaker.angle);
            return { x: beaker.x + p.x, y: beaker.y + p.y };
        }

        function getBeakerLowestWorldY(beaker) {
            const w = beaker.w, h = beaker.h;
            const corners = [
                {x: -w/2, y: -h/2}, {x: w/2, y: -h/2},
                {x: w/2, y: h/2},   {x: -w/2, y: h/2}
            ];
            let maxY = -Infinity;
            corners.forEach(c => {
                const p = rotatePoint(c.x, c.y, beaker.angle);
                if (p.y > maxY) maxY = p.y;
            });
            return beaker.y + maxY;
        }

        function drawBeaker(ctx, b, isSource) {
            ctx.save();
            ctx.translate(b.x, b.y);
            ctx.rotate(b.angle);

            const w = b.w;
            const h = b.h;

            // 玻璃
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(-w/2, -h/2, w, h);

            let surfaceWorldY = 9999;
            if (b.waterVolume > 0) {
                const spoutWorld = getSpoutTipWorldPos(b);
                const spoutY = spoutWorld.y; 
                const bottomY = getBeakerLowestWorldY(b); 
                const currentWaterDepth = (b.waterVolume / 100) * (h * 0.9); 
                
                surfaceWorldY = bottomY - currentWaterDepth;

                if ((surfaceWorldY < spoutY || (b.angle < -1.0 && b.waterVolume > 0.5)) && b.waterVolume > 0.5) {
                    surfaceWorldY = spoutY - 2; 
                    b.isPouring = true; 
                } else {
                    b.isPouring = false;
                }
            } else {
                b.isPouring = false;
            }

            // 水
            if (b.waterVolume > 0) {
                ctx.save();
                ctx.beginPath();
                ctx.rect(-w/2 + 2, -h/2, w-4, h-2);
                ctx.clip(); 

                ctx.rotate(-b.angle); 
                let localSurfaceY = surfaceWorldY - b.y;

                ctx.fillStyle = WATER_COLOR;
                ctx.beginPath();
                ctx.rect(-300, localSurfaceY, 600, 600); 
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(-300, localSurfaceY);
                ctx.lineTo(300, localSurfaceY);
                ctx.strokeStyle = WATER_STROKE;
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            }

            // 粒子
            if (isSource) {
                const leftWallX = -w/2 + 3; 
                const rightWallX = w/2 - 3;
                const bottomWallY = h/2 - 3;
                const spoutOpeningY = -h/2 + 45; 

                b.particles.forEach(p => {
                    if (p.alpha <= 0) return; 
                    
                    if (step === 4 && b.waterVolume > 0) {
                        const pWorld = rotatePoint(p.x, p.y, b.angle);
                        const pWorldY = b.y + pWorld.y;

                        if (pWorldY < surfaceWorldY) {
                            if (Math.abs(Math.cos(b.angle)) > 0.1) {
                                let newLocalY = (surfaceWorldY - b.y - p.x * Math.sin(b.angle)) / Math.cos(b.angle);
                                p.y = newLocalY + Math.random() * 5; 
                            } else {
                                p.x -= 2; 
                            }
                        }
                    }

                    if (step === 2 && b.waterVolume > 20) {
                        p.x += (Math.random() - 0.5) * 6; 
                        p.y += (Math.random() - 0.5) * 6;
                        
                        if(p.x < -w/2 + 10) p.x = -w/2 + 10; 
                        if(p.x > w/2 - 10) p.x = w/2 - 10;
                        if(p.y > h/2 - 5) p.y = h/2 - 5; 
                        
                        const currentWaterDepth = (b.waterVolume / 100) * (h * 0.9);
                        const surfaceLocalY = (h / 2) - currentWaterDepth;
                        
                        if (p.y < surfaceLocalY) {
                            p.y = surfaceLocalY + 2 + Math.random(); 
                        }
                    }
                    
                    if (step === 4 && b.angle < -0.5) {
                        if (Math.random() < 0.3) { p.x -= 2; p.y -= 1; }
                        
                        if (p.x > rightWallX) p.x = rightWallX;
                        if (p.y > bottomWallY) p.y = bottomWallY;

                        if (p.x < leftWallX) {
                            if (p.y > spoutOpeningY) {
                                p.x = leftWallX; 
                            } else {
                                if (p.x < leftWallX - 25) {
                                    if (b.isPouring) p.alpha = 0; 
                                    else p.x = leftWallX - 25; 
                                }
                            }
                        }
                        
                        if (p.x < leftWallX && p.y < spoutOpeningY && b.isPouring) {
                             if (p.type === 'sand' && Math.random() < 0.15) p.alpha = 0; 
                        }
                    } else {
                        if (p.x < leftWallX) p.x = leftWallX;
                        if (p.x > rightWallX) p.x = rightWallX;
                        if (p.y > bottomWallY) p.y = bottomWallY;
                    }

                    ctx.fillStyle = p.type === 'sand' ? SAND_COLOR : `rgba(255,255,255,${p.alpha})`;
                    ctx.beginPath();
                    if (p.type === 'salt') ctx.rect(p.x - p.r, p.y - p.r, p.r*2, p.r*2);
                    else ctx.arc(p.x, p.y, p.r + 0.5, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            ctx.strokeStyle = '#889'; ctx.lineWidth = 4; ctx.lineJoin = 'round'; ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(w/2, -h/2); ctx.lineTo(w/2, h/2 - 15); ctx.quadraticCurveTo(w/2, h/2, w/2 - 15, h/2); ctx.lineTo(-w/2 + 15, h/2); ctx.quadraticCurveTo(-w/2, h/2, -w/2, h/2 - 15); 
            if(isSource) {
                ctx.lineTo(-w/2, -h/2 + 20); ctx.lineTo(-w/2 - 15, -h/2 - 5); ctx.stroke();
            } else {
                ctx.lineTo(-w/2, -h/2); ctx.stroke();
            }
            ctx.fillStyle = '#889'; ctx.fillRect(-w/2 + 5, 0, 15, 3); ctx.fillRect(-w/2 + 5, 40, 20, 3); ctx.fillRect(-w/2 + 5, -40, 15, 3);
            ctx.restore();
        }

        function smoothSandPile() {
            const threshold = 1.0; const transferRate = 0.4; 
            for (let pass = 0; pass < 2; pass++) { 
                for (let i = 0; i < filterSetup.pileHeights.length - 1; i++) {
                    let diff = filterSetup.pileHeights[i] - filterSetup.pileHeights[i+1];
                    if (diff > threshold) {
                        let transfer = diff * transferRate;
                        filterSetup.pileHeights[i] -= transfer;
                        filterSetup.pileHeights[i+1] += transfer;
                    }
                }
                for (let i = filterSetup.pileHeights.length - 1; i > 0; i--) {
                    let diff = filterSetup.pileHeights[i] - filterSetup.pileHeights[i-1];
                    if (diff > threshold) {
                        let transfer = diff * transferRate;
                        filterSetup.pileHeights[i] -= transfer;
                        filterSetup.pileHeights[i-1] += transfer;
                    }
                }
            }
        }

        function updateAndDrawPouringSystem(ctx) {
            let bottomIsFull = filterSetup.beakerBWaterLevel >= MAX_BOTTOM_LEVEL;
            let topIsAlmostEmpty = beakerA.waterVolume <= 0.5;

            if (step === 4 && beakerA.isPouring && !topIsAlmostEmpty && !bottomIsFull) {
                const spoutPos = getSpoutTipWorldPos(beakerA);
                let flowRate = 2; 

                for(let k=0; k < flowRate; k++) {
                    filterSetup.fallingParticles.push({
                        type: 'water',
                        x: spoutPos.x + (Math.random()-0.5)*3, 
                        y: spoutPos.y + (Math.random()-0.5)*3,
                        vx: -0.5 + (Math.random()-0.5)*0.5, 
                        vy: 1 + Math.random(),      
                        r: 2.5 + Math.random()*1.5,
                        life: 100
                    });
                }

                let sandLeft = beakerA.particles.some(p => p.type === 'sand' && p.alpha > 0);
                
                let shouldPourSand = filterSetup.beakerBWaterLevel < MAX_BOTTOM_LEVEL - 5;

                // V40/41/42 修正：保留高沙量 (0.9)
                if (sandLeft && Math.random() < 0.9 && shouldPourSand) {
                    let count = Math.floor(Math.random() * 3) + 2; 
                    for(let i=0; i<count; i++) {
                        filterSetup.fallingParticles.push({
                            type: 'sand',
                            x: spoutPos.x + (Math.random()-0.5)*4, 
                            y: spoutPos.y + (Math.random()-0.5)*4,
                            vx: -0.2 + (Math.random()-0.5)*0.5, 
                            vy: 1.5 + Math.random(),
                            r: 3.5, 
                            life: 100
                        });
                    }
                }
            }

            const sieveY = filterSetup.y - filterSetup.beakerBSize.h + 40;
            const sieveX = filterSetup.x;
            const sieveStartIdxX = sieveX - filterSetup.sieveRadius;
            
            for (let i = filterSetup.fallingParticles.length - 1; i >= 0; i--) {
                let p = filterSetup.fallingParticles[i];
                p.vx *= 0.98; p.vy += 0.25; 
                p.x += p.vx; p.y += p.vy;
                
                ctx.beginPath();
                ctx.fillStyle = (p.type === 'water') ? WATER_COLOR : SAND_COLOR;
                ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
                ctx.fill();

                if (p.y >= sieveY) {
                    if (Math.abs(p.x - sieveX) < filterSetup.sieveRadius) {
                        if (p.type === 'water') {
                            filterSetup.beakerBWaterLevel += 0.2; 
                            if (filterSetup.beakerBWaterLevel > MAX_BOTTOM_LEVEL) {
                                filterSetup.beakerBWaterLevel = MAX_BOTTOM_LEVEL;
                            }
                            filterSetup.fallingParticles.splice(i, 1);
                        } else {
                            let relativeX = p.x - sieveStartIdxX;
                            let distFromCenter = p.x - sieveX;
                            if (Math.abs(distFromCenter) > 20) {
                                relativeX -= Math.sign(distFromCenter) * 15; 
                            }
                            
                            let idx = Math.floor(relativeX);
                            if (idx >= 10 && idx < filterSetup.pileHeights.length - 10) { 
                                // V42 修正：堆積速度調降至 3.0
                                filterSetup.pileHeights[idx] += 3.0; 
                            }
                            filterSetup.fallingParticles.splice(i, 1);
                        }
                    } else if (p.y > canvas.height) {
                        filterSetup.fallingParticles.splice(i, 1);
                    }
                }
            }
            smoothSandPile();
        }

        function drawJug(ctx) {
            if (!jug.visible) return;
            ctx.save(); ctx.translate(jug.x, jug.y); ctx.rotate(jug.angle); 
            ctx.fillStyle = '#e3f2fd'; ctx.strokeStyle = '#90caf9'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(-40, -50); ctx.lineTo(-40, 50); ctx.lineTo(40, 50); ctx.lineTo(40, -50); ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(40, -30); ctx.quadraticCurveTo(60, -20, 40, 30); ctx.stroke();
            if (jug.flow) {
                ctx.rotate(-jug.angle); 
                const streamX = -50; 
                const streamY = -20; 
                
                const beakerBottomY = beakerA.y + beakerA.h / 2;
                const waterDepth = (beakerA.waterVolume / 100) * (beakerA.h * 0.9);
                const waterSurfaceWorldY = beakerBottomY - waterDepth;
                const streamStartWorldY = jug.y + streamY;
                
                let visibleLength = waterSurfaceWorldY - streamStartWorldY;
                if (visibleLength < 0) visibleLength = 0; 

                ctx.fillStyle = WATER_COLOR; 
                ctx.beginPath(); 
                ctx.moveTo(streamX - 5, streamY); 
                ctx.lineTo(streamX + 5, streamY); 
                ctx.lineTo(streamX + 5, streamY + visibleLength); 
                ctx.lineTo(streamX - 5, streamY + visibleLength); 
                ctx.fill();
            }
            ctx.restore();
        }

        function drawRod(ctx) {
            if (!rod.visible) return;
            ctx.save(); ctx.translate(rod.x, rod.y);
            if (rod.moving) { let offset = Math.sin(Date.now() / 100) * 30; ctx.translate(offset, 0); }
            ctx.rotate(0.2); 
            ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.strokeStyle = '#ccc'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.rect(-4, -120, 8, 260); ctx.fill(); ctx.stroke();
            ctx.restore();
        }

        function drawFilterSetup(ctx) {
            if (!filterSetup.visible) return;
            const fx = filterSetup.x, fy = filterSetup.y, r = filterSetup.sieveRadius;
            
            ctx.save(); 
            ctx.translate(fx, fy);
            ctx.save(); 
            ctx.translate(0, -filterSetup.beakerBSize.h + 40); 
            
            ctx.fillStyle = '#ddd'; ctx.fillRect(r - 10, -5, 70, 12); 
            ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI, false); ctx.strokeStyle = '#666'; ctx.lineWidth = 5; ctx.stroke(); ctx.fillStyle = 'rgba(230,230,230,0.3)'; ctx.fill();
            
            ctx.save(); 
            ctx.beginPath(); 
            ctx.arc(0, 0, r, 0, Math.PI, false); 
            ctx.clip(); 
            ctx.strokeStyle = '#999'; ctx.lineWidth = 1.5; 
            ctx.beginPath();
            for(let i = -r; i <= r; i+=10) { ctx.moveTo(i, 0); ctx.lineTo(i, r); ctx.moveTo(-r, Math.abs(i)); ctx.lineTo(r, Math.abs(i)); } 
            ctx.stroke();
            ctx.restore(); 

            const startX = -r; 
            ctx.beginPath();
            
            let firstPoint = true;
            for (let i = 0; i < filterSetup.pileHeights.length; i++) {
                let x = startX + i;
                if (x >= -r && x <= r) {
                    let sieveY = Math.sqrt(r*r - x*x);
                    let sandTopY = sieveY - filterSetup.pileHeights[i];
                    if (sandTopY < 0) sandTopY = 0;

                    if (firstPoint) {
                        ctx.moveTo(x, sandTopY);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(x, sandTopY);
                    }
                }
            }
            
            for (let i = filterSetup.pileHeights.length - 1; i >= 0; i--) {
                let x = startX + i;
                if (x >= -r && x <= r) {
                    let sieveY = Math.sqrt(r*r - x*x);
                    ctx.lineTo(x, sieveY);
                }
            }
            
            ctx.closePath();
            ctx.fillStyle = SAND_COLOR; 
            ctx.fill();
            
            ctx.restore(); 
            ctx.restore(); 
            
            ctx.save(); ctx.translate(fx, fy);
            let bObj = { 
                x:0, y:0, 
                w: filterSetup.beakerBSize.w, 
                h: filterSetup.beakerBSize.h, 
                angle:0, 
                waterVolume: filterSetup.beakerBWaterLevel, 
                spoutLocal: { x: -filterSetup.beakerBSize.w/2, y: -filterSetup.beakerBSize.h/2 } 
            };
            drawBeaker(ctx, bObj, false); 
            ctx.restore();
        }

        function update() {
            if (step === 1) { 
                jug.visible = true; jug.x = beakerA.x + 50; jug.y = beakerA.y - 200; 
                if (!jug.returned) {
                    if (jug.angle > -0.8 && !jug.flowDone) jug.angle -= 0.05;
                    else if (!jug.flowDone) { 
                        jug.flow = true; 
                        if(beakerA.waterVolume < beakerA.maxVolume) beakerA.waterVolume += 0.5; 
                        else { jug.flow = false; jug.flowDone = true; } 
                    }
                    else { if(jug.angle < 0) { jug.angle += 0.05; if(jug.angle >= 0) { jug.angle = 0; jug.returned = true; } } }
                }
            } else jug.visible = false;

            if (step === 2) { 
                rod.visible = true; rod.x = beakerA.x; rod.y = beakerA.y - 70; rod.moving = true;
                beakerA.particles.forEach(p => { if (p.type === 'salt' && p.alpha > 0) p.alpha -= 0.005; });
            } else rod.visible = false;

            if (step === 3) { 
                filterSetup.x += (width * 0.5 - filterSetup.x) * 0.05;
                filterSetup.y += (height * 0.75 - filterSetup.y) * 0.05;
                
                const targetBeakerX = filterSetup.x + 105; 
                const targetBeakerY = (height * 0.75 - 350); 
                
                beakerA.x += (targetBeakerX - beakerA.x) * 0.05;
                beakerA.y += (targetBeakerY - beakerA.y) * 0.05;
                filterSetup.visible = true;
            }

            if (step === 4) { 
                const targetAngle = -Math.PI / 2 - 0.4; 
                if (beakerA.angle > targetAngle) beakerA.angle -= 0.004; 

                let bottomIsFull = filterSetup.beakerBWaterLevel >= MAX_BOTTOM_LEVEL;

                if (beakerA.isPouring && beakerA.waterVolume > 0.5 && !bottomIsFull) {
                    let drainRate = 0.015;
                    if (drainRate < 0.005) drainRate = 0.005; 
                    beakerA.waterVolume -= drainRate; 
                    
                    if (beakerA.waterVolume <= 0.5) {
                        beakerA.waterVolume = 0; 
                        beakerA.isPouring = false; 
                        filterSetup.fallingParticles = [];
                        beakerA.particles = [];
                        if (step === 4) { 
                            step = 5; 
                            updateUI(5); 
                            if(autoStepTimer) clearTimeout(autoStepTimer); 
                        }
                    }
                } else if (bottomIsFull) {
                    beakerA.waterVolume = 0; 
                    beakerA.isPouring = false;
                    filterSetup.fallingParticles = [];
                    beakerA.particles = [];
                    if (step === 4) { 
                        step = 5; 
                        updateUI(5); 
                        if(autoStepTimer) clearTimeout(autoStepTimer); 
                    }
                }
            }
        }

        function loop() {
            animFrame = requestAnimationFrame(loop);
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#eef'; ctx.fillRect(0, height * 0.7 + 100, width, height);
            ctx.strokeStyle = '#ccc'; ctx.beginPath(); ctx.moveTo(0, height * 0.7 + 100); ctx.lineTo(width, height * 0.7 + 100); ctx.stroke();
            update();
            if (step >= 3) drawFilterSetup(ctx);
            drawBeaker(ctx, beakerA, true); 
            if (step === 1) drawJug(ctx);
            if (step === 2) drawRod(ctx);
            updateAndDrawPouringSystem(ctx);
        }

        const stepsData = [
            { t: "步驟 1：觀察混合物", d: "燒杯中有大量的沙子（棕色）與食鹽（白色）混合物，約佔杯身 1/3。", btn: "加入清水" },
            { t: "步驟 2：加水溶解", d: "水柱準確注入燒杯中，準備溶解食鹽。", btn: "開始攪拌" },
            { t: "步驟 3：攪拌加速溶解", d: "玻璃棒深入底部攪拌。食鹽溶解消失，沙子沉澱。", btn: "準備篩網" },
            { t: "步驟 4：準備過濾", d: "裝置移至中央。準備過濾。", btn: "倒入混合液" },
            { t: "步驟 5：過濾分離", d: "沙子平整地堆積在篩網上，食鹽水濾出。", btn: "完成實驗" },
            { t: "實驗完成", d: "實驗成功！篩網上留下了所有的沙子。", btn: "重新開始" }
        ];

        function updateUI(s) {
            const data = stepsData[s]; titleEl.textContent = data.t; descEl.textContent = data.d;
            if (s === 5) { mainBtn.style.display = 'none'; resetBtn.style.display = 'block'; }
            else { mainBtn.textContent = data.btn; mainBtn.style.display = 'block'; resetBtn.style.display = 'none'; }
            dots.forEach((d, i) => { if(i < 4) d.className = i === Math.min(s, 3) ? 'step-dot active' : 'step-dot'; });
        }

        mainBtn.addEventListener('click', () => {
            if (step < 5) {
                step++; updateUI(step);
                if (step === 1 || step === 2) { mainBtn.disabled = true; autoStepTimer = setTimeout(() => { mainBtn.disabled = false; autoStepTimer = null; }, 3000); }
                if (step === 4) { mainBtn.disabled = true; autoStepTimer = setTimeout(() => { step = 5; updateUI(5); autoStepTimer = null; }, 25000); }
            }
        });
        resetBtn.addEventListener('click', () => resetExperiment());
        init();
    </script>
</body>
</html>